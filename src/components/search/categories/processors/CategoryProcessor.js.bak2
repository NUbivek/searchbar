import { getDefaultCategories, getCategoriesByKeywords } from '../types';
import MetricsCalculator from '../../metrics/MetricsCalculator';
import { calculateCategoryMetrics } from '../metrics';
import { getCategoryColor, getCategoryIcon } from '../utils';
import { extractBusinessInsights, isBusinessQuery } from '../../utils';
import CategoryFinder from '../CategoryFinder';

// Safely process LLM response object
const safeLLMResponseProcessor = (llmResponse) => {
  if (!llmResponse) return null;
  
  try {
    // If it's a string, just return it
    if (typeof llmResponse === 'string') return llmResponse;
    
    // If it's an object with content property, extract it
    if (typeof llmResponse === 'object' && llmResponse.content) {
      return llmResponse.content;
    }
    
    // If it's some other object format we don't recognize
    if (typeof llmResponse === 'object') {
      // Try to stringify it
      try {
        return JSON.stringify(llmResponse);
      } catch (err) {
        console.warn('Could not stringify LLM response object', err);
        return null;
      }
    }
    
    return null;
  } catch (error) {
    console.error('Error processing LLM response:', error);
    return null;
  }
};

// Utility function to calculate average of array values
const average = (arr) => {
  if (!arr || !Array.isArray(arr) || arr.length === 0) return 0;
  const sum = arr.reduce((a, b) => a + (typeof b === 'number' ? b : 0), 0);
  return sum / arr.length;
};

/**
 * Process content to extract and categorize into different categories
 * @param {Array|Object|string} content The content to categorize
 * @param {string} query The search query
 * @param {Object} options Additional options for processing
 * @returns {Array} Array of category objects with their content
 */
export async function processCategories(content, query = '', options = {}) {
  try {
    // Validate input
    if (!content || !Array.isArray(content)) {
      console.warn('Invalid content provided to processCategories:', content);
      return [];
    }

    // Log processing start
    console.log(`Processing ${content.length} items into categories with query: "${query}"`);
    
    // Extract sources from content if they have a URL
    const sources = content.filter(item => 
      item && typeof item === 'object' && 
      (item.isSource || item.url || (item.metadata && item.metadata.url))
    );
    
    if (sources.length > 0) {
      console.log(`Found ${sources.length} sources in content items`);
    }
    
    // Handle empty content
    if (!content || (Array.isArray(content) && content.length === 0)) {
      // Return a default "No Results" category
      return [{
        id: 'empty',
        name: 'No Results',
        description: 'No results found for your query',
        icon: 'search',
        content: [],
        metrics: { relevance: 0, accuracy: 0, credibility: 0, overall: 0 }
      }];
    }
    
    // Normalize content
    console.log('DEBUG: Normalizing content:', {
      contentType: typeof content,
      isArray: Array.isArray(content),
      length: Array.isArray(content) ? content.length : 0
    });
    
    // Process each content item and categorize it
    const normalizedContent = normalizeContent(content);
    
    console.log('DEBUG: Normalizing content:', {
      contentType: typeof content,
      isArray: Array.isArray(content),
      contentLength: Array.isArray(content) ? content.length : 0
    });
    
    // Calculate metrics for each item
    const contentWithMetrics = normalizedContent.map(item => calculateItemMetrics(item, query, sources));
    
    // Use CategoryFinder to categorize content
    console.log('DEBUG: Before categorizeContentWithFinder');
    const categorizedContent = await categorizeContentWithFinder(contentWithMetrics, query, sources, options);
    console.log('DEBUG: After categorizeContentWithFinder - Result:', {
      type: typeof categorizedContent,
      isArray: Array.isArray(categorizedContent),
      length: Array.isArray(categorizedContent) ? categorizedContent.length : 0
    });
    
    console.log(`Categorized content into ${categorizedContent.length} categories`);
    
    // Add hasExpandableContent flag for categories with more than 3 content items
    // Add hyperlinks to content items
    for (const category of categorizedContent) {
      if (category && category.content && Array.isArray(category.content)) {
        // Set expandable content flag if more than 3 items
        if (category.content.length > 3) {
          category.hasExpandableContent = true;
        }
        
        // Add hyperlinks to content
        category.content = category.content.map(item => {
          if (!item) return item;
          
          // Skip if already processed
          if (item._hasHyperlinks) return item;
          
          // Get item text and URL
          const itemText = typeof item === 'string' ? item : 
                          (item.content || item.description || item.snippet || '');
          const itemUrl = typeof item === 'object' ? 
                          (item.url || item.link || 
                           (item.metadata && (item.metadata.url || item.metadata.link)) || '') : '';
          
          // Skip if no URL or text
          if (!itemUrl || !itemText) return item;
          
          // Create a modified item with hyperlinks
          const modifiedItem = { ...item };
          
          // Find important keywords in content to link
          const keywords = itemText.match(/\b([A-Z][a-z]+(?:\s[A-Z][a-z]+)*)\b/g) || [];
          const uniqueKeywords = [...new Set(keywords)].slice(0, 3);
          
          // Create content with hyperlinks only if we found keywords and have URL
          if (uniqueKeywords.length > 0 && itemUrl) {
            let contentWithLinks = itemText;
            
            // Replace keywords with hyperlinks
            uniqueKeywords.forEach(keyword => {
              // Replace only the first occurrence of each keyword
              if (contentWithLinks.includes(keyword)) {
                contentWithLinks = contentWithLinks.replace(
                  new RegExp(`\\b${keyword}\\b`), 
                  `<a href="${itemUrl}" target="_blank" rel="noopener noreferrer">${keyword}</a>`
                );
              }
            });
            
            // Update item with hyperlinked content
            if (typeof modifiedItem === 'object') {
              modifiedItem.contentWithLinks = contentWithLinks;
              if (modifiedItem.content) modifiedItem.content = contentWithLinks;
              if (modifiedItem.description) modifiedItem.description = contentWithLinks;
              if (modifiedItem.snippet) modifiedItem.snippet = contentWithLinks;
              modifiedItem._hasHyperlinks = true;
            }
          }
          
          return modifiedItem;
        });
      }
    }
    
    // Add metrics to each category
    for (const category of categorizedContent) {
      if (category) {
        category.metrics = calculateCategoryMetricsWithBoost(category);
      }
    }
    
    // Sort categories by overall metrics score (descending)
    const sortedCategories = sortCategoriesByMetrics(categorizedContent);
    
    console.log(`Generated ${sortedCategories.length} categories with details:`, sortedCategories.map(c => ({
      id: c.id,
      name: c.name,
      itemCount: c.content?.length || 0,
      metrics: c.metrics
    })));
    
    // Return categories
    return sortedCategories;
  } catch (error) {
    console.error('Error processing categories:', error);
    // Return empty categories
    return [];
  }
}

/**
 * Process a single category to include business insights
 * @param {Object} category The category to process
 * @param {string} query The search query
 * @param {Object} options Additional options for processing
 * @returns {Object} The processed category
 */
export function processCategory(category, query, options = {}) {
  if (!category) return null;
  
  // Create a processed copy of the category
  const processedCategory = { ...category };
  
  // Calculate metrics for the category
  try {
    const metrics = calculateCategoryMetricsWithBoost(category);
    processedCategory.metrics = metrics;
  } catch (error) {
    console.error(`Error calculating metrics for category ${category.name}:`, error);
  }
  
  // Extract insights for business categories
  if (
    processedCategory.name && 
    (processedCategory.name.toLowerCase().includes('business') || 
     processedCategory.name.toLowerCase().includes('financial') || 
     processedCategory.name.toLowerCase().includes('market') || 
     processedCategory.name.toLowerCase().includes('economic') ||
     processedCategory.name.toLowerCase().includes('company') ||
     processedCategory.name.toLowerCase().includes('industry'))
  ) {
    try {
      const allContent = Array.isArray(category.content) 
        ? category.content.map(item => {
            return [
              item.title || '',
              item.description || item.snippet || '',
              item.content || ''
            ].join(' ');
          }).join(' ')
        : '';
        
      if (allContent) {
        processedCategory.businessInsights = extractBusinessInsights(allContent, query, {
          maxInsights: 8,
          categoryName: processedCategory.name
        });
      }
    } catch (error) {
      console.error(`Error extracting business insights for category ${category.name}:`, error);
    }
  }
  
  // Add visual elements
  try {
    processedCategory.color = getCategoryColor(category.type || category.name);
    processedCategory.icon = getCategoryIcon(category.type || category.name);
  } catch (error) {
    console.error(`Error adding visual elements for category ${category.name}:`, error);
  }
  
  return processedCategory;
}

/**
 * Generate key insights for business categories
 * @param {Array} categories Array of categories with content
 * @param {string} query The search query
 * @returns {Array} Categories with added key insights
 */
const generateKeyInsights = (categories, query) => {
  return categories.map(category => {
    // Skip if not a business category or no content
    if (!category.businessCategory || !category.content || category.content.length === 0) {
      return category;
    }
    
    // Extract key insights from content
    const keyInsights = [];
    
    // Sort content by metrics first
    const sortedContent = [...category.content].sort((a, b) => {
      const aMetrics = a.metrics || {};
      const bMetrics = b.metrics || {};
      return (bMetrics.relevance || 0) - (aMetrics.relevance || 0);
    });
    
    // Take top 3 items for insights
    const topItems = sortedContent.slice(0, 3);
    
    // Extract insights based on category type
    switch (category.id) {
      case 'market_analysis':
        keyInsights.push('Market trends indicate ' + extractKeyPhrase(topItems[0]));
        if (topItems.length > 1) {
          keyInsights.push('Analysis shows ' + extractKeyPhrase(topItems[1]));
        }
        break;
        
      case 'financial_data':
        keyInsights.push('Financial metrics show ' + extractKeyPhrase(topItems[0]));
        if (topItems.length > 1) {
          keyInsights.push('Key financial indicators: ' + extractKeyPhrase(topItems[1]));
        }
        break;
        
      case 'company_information':
        keyInsights.push('Company profile highlights: ' + extractKeyPhrase(topItems[0]));
        break;
        
      case 'industry_trends':
        keyInsights.push('Industry analysis indicates ' + extractKeyPhrase(topItems[0]));
        break;
        
      default:
        // For other business categories, extract general insights
        if (topItems.length > 0) {
          keyInsights.push(extractKeyPhrase(topItems[0]));
        }
        if (topItems.length > 1) {
          keyInsights.push(extractKeyPhrase(topItems[1]));
        }
    }
    
    return {
      ...category,
      keyInsights
    };
  });
};

/**
 * Extract a key phrase from a content item
 * @param {Object} item Content item
 * @returns {string} Extracted key phrase
 */
const extractKeyPhrase = (item) => {
  if (!item) return '';
  
  const text = getTextFromItem(item);
  if (!text) return '';
  
  // Extract first sentence or first 100 characters
  const firstSentence = text.split(/[.!?]/).filter(s => s.trim().length > 0)[0] || '';
  return firstSentence.trim().substring(0, 100) + (firstSentence.length > 100 ? '...' : '');
};

/**
 * Normalize content into a standard array format
 * @param {Array|Object|string} content The content to normalize
 * @returns {Array} Normalized content array
 */
const normalizeContent = (content) => {
  try {
    // Log the content type for debugging
    console.log('DEBUG: Normalizing content:', {
      contentType: typeof content,
      isArray: Array.isArray(content),
      contentLength: Array.isArray(content) ? content.length : 0
    });
    
    // If content is already an array, process each item
    if (Array.isArray(content)) {
      // Map each item to a normalized format
      return content.map(item => normalizeContentItem(item));
    }
    
    // If content is an object, convert to array with one item
    if (content && typeof content === 'object') {
      return [normalizeContentItem(content)];
    }
    
    // If content is a string, create a text item
    if (typeof content === 'string') {
      return [{
        title: 'Text Content',
        content: content,
        type: 'text'
      }];
    }
    
    // Default empty array for invalid content
    console.warn('Invalid content format for normalization:', typeof content);
    return [];
  } catch (error) {
    console.error('Error normalizing content:', error);
    return [];
  }
};

/**
 * Normalize a single content item
 * @param {Object|string} item The item to normalize
 * @returns {Object} Normalized item
 */
const normalizeContentItem = (item) => {
  try {
    // If item is a string, create a text item
    if (typeof item === 'string') {
      return {
        title: 'Text Content',
        content: item,
        type: 'text'
      };
    }
    
    // If item is not an object, create a basic item
    if (!item || typeof item !== 'object') {
      return {
        title: 'Unknown Content',
        content: String(item),
        type: 'unknown'
      };
    }
    
    // Extract content from various possible properties
    const content = item.content || item.snippet || item.description || item.text || '';
    
    // Create a normalized item with all possible properties
    return {
      ...item, // Keep all original properties
      title: item.title || item.name || 'Untitled',
      content: typeof content === 'string' ? content : JSON.stringify(content),
      url: item.url || item.link || '',
      source: item.source || item.provider || 'unknown',
      type: item.type || (item.isSource ? 'source' : 'content'),
      // Add metadata if available
      metadata: item.metadata || {}
    };
  } catch (error) {
    console.error('Error normalizing content item:', error);
    return {
      title: 'Error Item',
      content: 'Error processing this item',
      type: 'error'
    };
  }
};

/**
 * Categorize content using the new CategoryFinder
 * @param {Array} content Normalized content items
 * @param {string} query Search query
 * @param {Array} sources Source items
 * @param {Object} options Processing options
 * @returns {Array} Array of categories with their content
 */
async function categorizeContentWithFinder(content, query, sources = [], options = {}) {
  console.log('DEBUG: Using CategoryFinder to categorize content with advanced constraints');
  // Process options including llmResponse for summarization
  let llmContent = null;
  if (options.llmResponse) {
    llmContent = safeLLMResponseProcessor(options.llmResponse);
    if (llmContent) {
      console.log("Successfully processed LLM response for categorization");
    }
  }
  
  // Create a new instance of CategoryFinder
  const categoryFinder = new CategoryFinder();
  
  // Get all categories from CategoryFinder
  const allCategories = categoryFinder.CATEGORIES;
  
  // Initialize result categories
  const resultCategories = [];
  
  // Track which items have been categorized
  const categorizedItemIds = new Set();
  
  // Track categories with their content
  const categoryMap = {};
  
  // Check if this is a business query
  const isBusinessQueryContext = isBusinessQuery(query);
  console.log(`Query "${query}" is business query: ${isBusinessQueryContext}`);
  
  // Define business category IDs for prioritization
  const businessCategoryIds = [
    'business', 'investment', 'financial', 'market', 'industry', 'economic',
    'strategy', 'trends', 'forecast', 'analysis', 'entrepreneurship', 'startups',
    'ventureFunding', 'marketResearch', 'financialOverview', 'businessStrategy'
  ];
  
  // First pass: Find the best category for each item with LOWER threshold (40%)
  content.forEach(item => {
    // Skip if item is invalid
    if (!item || typeof item !== 'object') return;
    
    // Track item by unique ID or generate one
    const itemId = item.id || `${item.title}-${item.url || Math.random().toString(36).substring(7)}`;
    
    // Find best matching category
    const bestCategoryMatch = categoryFinder.findBestCategory(item, query, sources);
    
    // Skip if no match found
    if (!bestCategoryMatch) return;
    
    // Extract category and score
    const { category, score } = bestCategoryMatch;
    
    // Set appropriate threshold based on verification status and query type
    let threshold = 0.4; // Lower default threshold (was 0.7)
    
    if (item.isVerified) {
      // Much lower threshold for verified sources (only 10%)
      threshold = 0.1;
    } else if (isBusinessQueryContext) {
      // More lenient threshold for business queries (40%)
      threshold = 0.4;
    }
    
    // Skip if category not found or below threshold
    if (!category || score < threshold) return;
    
    // Check if the category is a business category
    const isBusinessCategory = businessCategoryIds.includes(category.id);
    
    // Calculate priority with business boost
    const priorityBoost = (isBusinessQueryContext && isBusinessCategory) ? 5 : 0;
    const priority = (score * 10) + priorityBoost;
    
    // Add item to category map
    if (!categoryMap[category.id]) {
      categoryMap[category.id] = {
        id: category.id,
        name: category.name,
        description: category.description || `Results related to ${category.name}`,
        icon: getCategoryIcon(category.id),
        color: getCategoryColor(category.id),
        businessCategory: isBusinessCategory,
        priority,
        content: []
      };
    }
    
    // Add item to category content
    categoryMap[category.id].content.push(item);
    
    // Mark item as categorized
    categorizedItemIds.add(itemId);
  });
  
  // Convert category map to array
  const categories = Object.values(categoryMap);
  
  // Create a generic category for all remaining uncategorized items
  const uncategorizedItems = content.filter(item => {
    if (!item || typeof item !== 'object') return false;
    
    // Check if item has been categorized
    const itemId = item.id || `${item.title}-${item.url || Math.random().toString(36).substring(7)}`;
    return !categorizedItemIds.has(itemId);
  });
  
  // If we have uncategorized items, create a generic category
  if (uncategorizedItems.length > 0) {
    console.log(`Creating generic category for ${uncategorizedItems.length} uncategorized items`);
    
    categories.push({
      id: 'generic',
      name: 'General Results',
      description: `General search results for "${query}"`,
      icon: 'search',
      color: '#4285F4',
      businessCategory: isBusinessQueryContext,
      priority: 1,
      content: uncategorizedItems
    });
  }
  
  // If we still have no categories but have content, create a default category with everything
  if (categories.length === 0 && content.length > 0) {
    console.log(`Creating default category with all ${content.length} items`);
    
    categories.push({
      id: 'all_results',
      name: 'Search Results',
      description: `All search results for "${query}"`,
      icon: 'search',
      color: '#4285F4',
      businessCategory: isBusinessQueryContext,
      priority: 0,
      content: content
    });
  }
  
  console.log(`Created ${categories.length} categories from content`);
  return categories;
}

/**
 * Calculate the Relevance & Recency metric for a category
 * @param {Object} category - The category to calculate metrics for
 * @param {string} query - The search query
 * @returns {number} - Relevance & Recency score (0-1)
 */
function calculateCategoryRelevanceAndRecency(category, query) {
  try {
    if (!category || !category.content || !Array.isArray(category.content)) {
      return 0; // Default to 0 for empty categories
    }

    // Calculate base relevance from content items
    let relevanceSum = 0;
    let itemCount = 0;

    for (const item of category.content) {
      // Skip invalid items
      if (!item) continue;
      
      // Extract text content for analysis
      const itemText = extractTextFromItem(item);
      if (!itemText) continue;
      
      // Calculate match with category keywords
      const keywords = category.keywords || [];
      const relevance = calculateRelevance(itemText, keywords, query);
      
      // Apply business context bonus if applicable
      const businessBonus = businessContentDetector(item, query) ? 0.2 : 0;
      
      // Apply query match bonus (if item content contains query terms)
      const queryBonus = query && itemText.toLowerCase().includes(query.toLowerCase()) ? 0.15 : 0;
      
      // Normalize to 0-1 range and apply bonuses
      const normalizedRelevance = (relevance / 100) + businessBonus + queryBonus;
      
      // Cap at 1.0
      const cappedRelevance = Math.min(normalizedRelevance, 1.0);
      
      relevanceSum += cappedRelevance;
      itemCount++;
    }
      
    // Calculate average relevance
    const avgRelevance = itemCount > 0 ? (relevanceSum / itemCount) : 0;
      
    // Apply business category boost
    const categoryBoost = category.businessCategory ? 0.15 : 0;
      
    // Apply priority boost (higher priority categories get slightly higher relevance)
    const priorityBoost = category.priority && category.priority < 3 ? 0.1 : 0;
      
    // Calculate final score with boosts
    let finalScore = avgRelevance + categoryBoost + priorityBoost;
      
    // Cap at 1.0
    return Math.min(finalScore, 1.0);
  } catch (error) {
    console.error('Error calculating category relevance:', error);
    return 0; // Default to 0 in case of errors
  }
}

/**
 * Calculate the Accuracy metric for a category
 * @param {Object} category - The category to calculate metrics for
 * @returns {number} - Accuracy score (0-1)
 */
function calculateCategoryAccuracy(category) {
  try {
    if (!category || !category.content || !Array.isArray(category.content)) {
      return 0; // Default to 0 for empty categories
    }
      
    // Calculate accuracy based on content attributes
    let accuracySum = 0;
    let itemCount = 0;
      
    for (const item of category.content) {
      if (!item) continue;
        
      // Base accuracy value to start with
      let itemAccuracy = 0.5; // Start with a moderate baseline accuracy
        
      // Boost accuracy for items with explicit metrics
      if (item.metrics && typeof item.metrics.accuracy === 'number') {
        itemAccuracy = item.metrics.accuracy;
      }
        
      // Boost accuracy for items with citations or references
      const itemText = extractTextFromItem(item);
      const hasCitations = itemText && (
        itemText.includes('according to') || 
        itemText.includes('cited by') || 
        itemText.includes('reference') || 
        itemText.includes('study') || 
        itemText.includes('research')
      );
        
      if (hasCitations) {
        itemAccuracy += 0.1;
      }
        
      // Cap at 1.0
      const cappedAccuracy = Math.min(itemAccuracy, 1.0);
        
      accuracySum += cappedAccuracy;
      itemCount++;
    }
      
    // Calculate average accuracy
    let avgAccuracy = itemCount > 0 ? (accuracySum / itemCount) : 0;
      
    // Apply data density bonus (categories with more specific data points)
    if (category.dataPoints && category.dataPoints.length > 0) {
      const dataPointsBonus = Math.min(category.dataPoints.length * 0.05, 0.2);
      avgAccuracy += dataPointsBonus;
    }
      
    // Cap at 1.0
    return Math.min(avgAccuracy, 1.0);
  } catch (error) {
    console.error('Error calculating category accuracy:', error);
    return 0; // Default to 0 in case of errors
  }
}

/**
 * Calculate the Credibility metric for a category
 * @param {Object} category - The category to calculate metrics for
 * @returns {number} - Credibility score (0-1)
 */
function calculateCategoryCredibility(category) {
  try {
    if (!category || !category.content || !Array.isArray(category.content)) {
      return 0; // Default to 0 for empty categories
    }
      
    // Extract unique sources
    const sources = new Set();
    for (const item of category.content) {
      if (!item) continue;
        
      // Add URL to sources set
      if (item.url) sources.add(item.url);
      if (item.link) sources.add(item.link);
      if (item.metadata && item.metadata.url) sources.add(item.metadata.url);
      if (item.metadata && item.metadata.link) sources.add(item.metadata.link);
    }
      
    // Source diversity bonus
    const sourceDiversityBonus = Math.min(sources.size * 0.1, 0.3);
      
    // Base credibility
    let baseCredibility = 0.5; // Start with a moderate baseline credibility
      
    // Calculate credibility from content items
    let credibilitySum = 0;
    let itemCount = 0;
      
    for (const item of category.content) {
      if (!item) continue;
        
      // Use explicit credibility if available
      let itemCredibility = baseCredibility;
      if (item.metrics && typeof item.metrics.credibility === 'number') {
        itemCredibility = item.metrics.credibility;
      }
        
      // Check for credibility indicators in content
      const itemText = extractTextFromItem(item);
      const hasCredibilityIndicators = itemText && (
        itemText.includes('expert') || 
        itemText.includes('verified') || 
        itemText.includes('official') || 
        itemText.includes('trusted') ||
        itemText.includes('report')
      );
        
      if (hasCredibilityIndicators) {
        itemCredibility += 0.1;
      }
        
      // Cap at 1.0
      const cappedCredibility = Math.min(itemCredibility, 1.0);
        
      credibilitySum += cappedCredibility;
      itemCount++;
    }
      
    // Calculate average credibility
    let avgCredibility = itemCount > 0 ? (credibilitySum / itemCount) : 0;
      
    // Apply source diversity bonus
    avgCredibility += sourceDiversityBonus;
      
    // Cap at 1.0
    return Math.min(avgCredibility, 1.0);
  } catch (error) {
    console.error('Error calculating category credibility:', error);
    return 0; // Default to 0 in case of errors
  }
}

/**
 * Calculate the overall score for a category based on its metrics
 * @param {Object} metrics - The metrics object with relevance, accuracy, and credibility
 * @returns {number} - Overall score (0-1)
 */
function calculateCategoryOverall(metrics) {
  // Default weights
  const weights = {
    relevance: 0.5,   // 50% weight for Relevance & Recency
    accuracy: 0.25,   // 25% weight for Accuracy
    credibility: 0.25 // 25% weight for Credibility
  };
  
  // Calculate weighted score
  const weightedScore = 
    (metrics.relevance * weights.relevance) +
    (metrics.accuracy * weights.accuracy) +
    (metrics.credibility * weights.credibility);
  
  // Ensure score is between 0 and 1
  return Math.max(0, Math.min(1, weightedScore));
}

/**
 * Extract text content from an item for keyword matching
 * @param {Object|string} item Content item
 * @returns {string} Text representation of the item
 */
const extractTextFromItem = (item) => {
  // If item is a string, return it directly
  if (typeof item === 'string') {
    return item;
  }
  
  // If item is not an object, convert to string
  if (!item || typeof item !== 'object') {
    return String(item || '');
  }
  
  // Extract text from various possible fields
  const textParts = [];
  
  // Title
  if (item.title) {
    textParts.push(item.title);
  }
  
  // Description or snippet
  if (item.description) {
    textParts.push(item.description);
  } else if (item.snippet) {
    textParts.push(item.snippet);
  }
  
  // Content
  if (typeof item.content === 'string') {
    textParts.push(item.content);
  } else if (item.text) {
    textParts.push(item.text);
  } else if (typeof item.content === 'object' && item.content !== null) {
    // Handle content that might be an object
    if (item.content.text) {
      textParts.push(item.content.text);
    }
    if (item.content.summary) {
      textParts.push(item.content.summary);
    }
  }
  
  // URL or link
  if (item.url) {
    textParts.push(item.url);
  } else if (item.link) {
    textParts.push(item.link);
  }
  
  // Source information
  if (item.source && typeof item.source === 'string') {
    textParts.push(item.source);
  }
  
  // Type information
  if (item.type && typeof item.type === 'string') {
    textParts.push(item.type);
  }
  
  // Join all parts with spaces
  return textParts.join(' ');
};

/**
 * Calculate relevance score for an item against a category
 * @param {string} itemText Text content of the item
 * @param {Array} keywords Category keywords
 * @param {string} query The search query
 * @returns {number} Relevance score (0-100)
 */
const calculateRelevance = (itemText, keywords, query) => {
  // Convert to lowercase for case-insensitive matching
  const lowerText = itemText.toLowerCase();
  const lowerQuery = query.toLowerCase();
  
  // Initialize score
  let score = 0;
  let matchCount = 0;
  let highValueMatches = 0;
  
  // Split text into words for more accurate matching
  const words = lowerText.split(/\s+/);
  const wordSet = new Set(words);
  
  // Extract query terms for context matching
  const queryTerms = lowerQuery.split(/\s+/).filter(term => term.length > 2);
  
  // Check each keyword
  keywords.forEach(keyword => {
    const lowerKeyword = keyword.toLowerCase();
    
    // Check if keyword is in the text
    if (lowerText.includes(lowerKeyword)) {
      matchCount++;
      
      // Base points for match
      let points = 10;
      
      // Bonus points for exact word match (with word boundaries)
      const wordRegex = new RegExp(`\\b${lowerKeyword}\\b`, 'i');
      if (wordRegex.test(lowerText)) {
        points += 10; // Increased from 5 to emphasize exact matches
        
        // Check if this is a multi-word keyword (higher value)
        if (lowerKeyword.includes(' ')) {
          points += 15; // Significant bonus for multi-word matches
          highValueMatches++;
        }
      }
      
      // Bonus points if keyword appears in query (query relevance)
      if (lowerQuery.includes(lowerKeyword)) {
        points += 20; // Increased from 15 to emphasize query relevance
      }
      
      // Bonus points for multiple occurrences
      const occurrences = (lowerText.match(new RegExp(lowerKeyword, 'gi')) || []).length;
      if (occurrences > 1) {
        points += Math.min(occurrences * 3, 15); // Increased cap to 15 bonus points
      }
      
      // Proximity bonus - check if keyword is near query terms
      let proximityBonus = 0;
      if (queryTerms.length > 0) {
        // Find positions of keyword in text
        let pos = 0;
        const keywordPositions = [];
        while (pos !== -1) {
          pos = lowerText.indexOf(lowerKeyword, pos);
          if (pos !== -1) {
            keywordPositions.push(pos);
            pos += lowerKeyword.length;
          }
        }
        
        // Find positions of query terms in text
        const queryTermPositions = [];
        queryTerms.forEach(term => {
          let pos = 0;
          while (pos !== -1) {
            pos = lowerText.indexOf(term, pos);
            if (pos !== -1) {
              queryTermPositions.push(pos);
              pos += term.length;
            }
          }
        });
        
        // Calculate proximity bonus based on closest distance
        if (keywordPositions.length > 0 && queryTermPositions.length > 0) {
          let minDistance = Infinity;
          for (const kPos of keywordPositions) {
            for (const qPos of queryTermPositions) {
              const distance = Math.abs(kPos - qPos);
              minDistance = Math.min(minDistance, distance);
            }
          }
          
          // Closer proximity = higher bonus (up to 15 points)
          if (minDistance < 100) {
            proximityBonus = Math.max(0, 15 - Math.floor(minDistance / 10));
          }
        }
      }
      
      // Add proximity bonus
      points += proximityBonus;
      
      // Add points to score
      score += points;
    }
  });
  
  // Additional context-aware bonuses
  
  // Bonus for high percentage of matched keywords
  const keywordMatchPercentage = matchCount / keywords.length;
  if (keywordMatchPercentage > 0.3) {
    score += Math.round(keywordMatchPercentage * 30); // Up to 30 bonus points
  }
  
  // Bonus for high-value matches (multi-word keywords)
  if (highValueMatches > 0) {
    score += Math.min(highValueMatches * 10, 30); // Up to 30 bonus points
  }
  
  // Normalize score based on number of keywords
  // A perfect score would be if all keywords matched with max points
  const maxPossibleScore = keywords.length * 70; // 70 is max points per keyword with bonuses
  const normalizedScore = Math.min(100, Math.round((score / Math.max(1, maxPossibleScore)) * 100));
  
  return normalizedScore;
};

// Business content detection utilities
const businessContentDetector = (item, query) => {
  // Extract text for analysis
  const text = extractTextFromItem(item).toLowerCase();
  const queryTerms = query ? query.toLowerCase().split(/\s+/) : [];
  
  // Business-related keywords
  const businessTerms = [
    'business', 'company', 'market', 'industry', 'finance', 'economic', 'strategy', 'growth', 
    'revenue', 'profit', 'sales', 'investment', 'investor', 'stock', 'startup', 'enterprise',
    'commercial', 'corporate', 'executive', 'management', 'leadership', 'ceo', 'cfo', 'cto',
    'roi', 'kpi', 'metrics', 'performance', 'analysis', 'forecast', 'trend', 'opportunity',
    'challenge', 'risk', 'competition', 'competitive', 'advantage', 'disadvantage', 'swot',
    'strength', 'weakness', 'threat', 'organization', 'operational', 'efficiency', 'productivity',
    'cost', 'pricing', 'value', 'customer', 'client', 'vendor', 'supplier', 'partner', 'alliance',
    'merger', 'acquisition', 'ipo', 'public offering', 'private equity', 'venture capital',
    'funding', 'investment', 'portfolio', 'asset', 'liability', 'balance sheet', 'income statement',
    'cash flow', 'dividend', 'shareholder', 'stakeholder', 'board', 'director', 'governance'
  ];
  
  // Check for business-related keywords
  const businessTermCount = businessTerms.filter(term => text.includes(term.toLowerCase())).length;
  
  // Check if query contains business terms
  const queryHasBusinessTerms = queryTerms.some(term => 
    businessTerms.some(businessTerm => businessTerm.includes(term) || term.includes(businessTerm))
  );
  
  // More lenient business content detection
  return businessTermCount > 0 || 
         text.includes('company') || 
         text.includes('organization') || 
         text.includes('market') ||
         text.includes('industry') ||
         text.includes('product') ||
         text.includes('service') ||
         text.includes('customer') ||
         text.includes('client') ||
         text.includes('solution') ||
         text.includes('technology') ||
         text.includes('innovation') ||
         text.includes('disruption') ||
         queryHasBusinessTerms;
};

const businessURLDetector = (item) => {
  // Check if the item has a URL
  if (!item.url) return false;
  
  const url = item.url.toLowerCase();
  
  // Business-related domains
  const businessDomains = [
    'business', 'company', 'corporate', 'enterprise', 'inc', 'corp', 'llc', 
    'finance', 'investor', 'market', 'industry', 'trade', 'commerce',
    'bloomberg', 'forbes', 'wsj', 'economist', 'ft.com', 'cnbc', 'reuters',
    'nasdaq', 'nyse', 'sec.gov', 'treasury', 'finance', 'investing', 'investment'
  ];
  
  // Check if URL contains business-related domains
  return businessDomains.some(domain => url.includes(domain));
};

// Default metrics for categories
const DEFAULT_CATEGORY_METRICS = {
  relevance: 0,
  accuracy: 0,
  credibility: 0,
  overall: 0,
  boostedRelevance: 0,
  boostedAccuracy: 0,
  boostedCredibility: 0,
  boostedOverall: 0,
  hasVerifiedSources: false
};

// Add category metrics based on content metrics
const calculateCategoryMetricsWithBoost = (category) => {
  // Get all metrics from content items, filtering out empty ones
  const contentMetrics = category.content
    .map(item => item.metrics)
    .filter(metrics => metrics && metrics.overall);
    
  if (contentMetrics.length === 0) return DEFAULT_CATEGORY_METRICS;
  
  // First check if we have any verified sources in this category
  const hasVerifiedSources = category.content.some(item => item.isVerified);
  
  // Calculate average metrics
  const relevance = average(contentMetrics.map(m => m.relevance));
  const accuracy = average(contentMetrics.map(m => m.accuracy));
  const credibility = average(contentMetrics.map(m => m.credibility));
  const overall = (relevance + accuracy + credibility) / 3;
  
  // For ranking, use boosted metrics if available
  const boostedRelevance = hasVerifiedSources ? 
    average(contentMetrics.map(m => m.boostedRelevance || m.relevance)) : relevance;
  const boostedAccuracy = hasVerifiedSources ? 
    average(contentMetrics.map(m => m.boostedAccuracy || m.accuracy)) : accuracy;
  const boostedCredibility = hasVerifiedSources ?
    average(contentMetrics.map(m => m.boostedCredibility || m.credibility)) : credibility;
  const boostedOverall = (boostedRelevance + boostedAccuracy + boostedCredibility) / 3;
  
  return {
    // Original metrics for display
    relevance,
    accuracy,
    credibility,
    overall,
    
    // Boosted metrics for ranking
    boostedRelevance,
    boostedAccuracy,
    boostedCredibility,
    boostedOverall,
    
    // Flag if this category has verified sources
    hasVerifiedSources
  };
};

/**
 * Sort categories by metrics, using boosted metrics for verified sources
 * @param {Array} categories Array of categories to sort
 * @returns {Array} Sorted categories
 */
const sortCategoriesByMetrics = (categories) => {
  // Check if we should use boosted metrics for sorting (if any category has verified sources)
  const useBookedMetrics = categories.some(cat => 
    cat.metrics && cat.metrics.hasVerifiedSources);
  
  return [...categories].sort((a, b) => {
    // Get the metrics to compare - boosted if available, otherwise regular
    const metricA = useBookedMetrics && a.metrics && a.metrics.boostedOverall ? 
      a.metrics.boostedOverall : (a.metrics ? a.metrics.overall : 0);
    const metricB = useBookedMetrics && b.metrics && b.metrics.boostedOverall ? 
      b.metrics.boostedOverall : (b.metrics ? b.metrics.overall : 0);
      
    return metricB - metricA;
  });
};

/**
 * Calculate metrics for an individual content item
 * @param {Object} item Content item
 * @param {string} query Search query
 * @param {Array} sources List of sources
 * @returns {Object} Item with metrics added
 */
function calculateItemMetrics(item, query, sources = []) {
  if (!item || typeof item !== 'object') return item;
  
  try {
    const itemText = item.content || item.snippet || item.description || '';
    const isVerified = item.isVerified || (item.metadata && item.metadata.isVerified) || false;
    
    // Use existing metric calculators
    const relevance = MetricsCalculator.calculateRelevanceAndRecency(item, query) * 100;
    const accuracy = MetricsCalculator.calculateAccuracy(item) * 100;
    const credibility = MetricsCalculator.calculateCredibility(item) * 100;
    const overall = (relevance + accuracy + credibility) / 3;
    
    // Apply non-linear boosting for verified sources
    let boostedRelevance = relevance;
    let boostedAccuracy = accuracy;
    let boostedCredibility = credibility;
    
    if (isVerified) {
      // Apply different boost factors for each component
      // Lower boost for relevance, medium for accuracy, high for credibility
      boostedRelevance = relevance * (1 + 0.25 * Math.log1p(relevance / 50));
      boostedAccuracy = accuracy * (1 + 0.40 * Math.log1p(accuracy / 50));
      boostedCredibility = credibility * (1 + 0.60 * Math.log1p(credibility / 50));
      
      // Cap at 98 to avoid perfect scores
      boostedRelevance = Math.min(98, boostedRelevance);
      boostedAccuracy = Math.min(98, boostedAccuracy);
      boostedCredibility = Math.min(98, boostedCredibility);
    }
    
    const boostedOverall = (boostedRelevance + boostedAccuracy + boostedCredibility) / 3;
    
    // Add metrics to item
    item.metrics = {
      relevance,
      accuracy,
      credibility,
      overall,
      boostedRelevance,
      boostedAccuracy,
      boostedCredibility,
      boostedOverall,
      isVerified
    };
    
    return item;
  } catch (error) {
    console.error('Error calculating metrics for item:', error);
    return item;
  }
}

// Define categories
export const CATEGORIES = {
  summary: {
    id: 'summary',
    name: 'Summary',
    description: 'AI-generated summary of search results',
    icon: 'fas fa-robot',
    color: '#4285F4', // Google Blue
    priority: 110, // Highest priority
    filter: (item) => item.isLLMSummary || item.type === 'summary',
  },
  business: {
    id: 'business',
    name: 'Business Insights',
    description: 'Information about business metrics, financials, and market trends',
    icon: 'fas fa-chart-line',
    color: '#34A853', // Google Green
    priority: 100,
    filter: (item, query) => {
      // Check if item has business-related content
      const hasBusinessContent = businessContentDetector(item, query);
      
      // Check if item has business-related URL
      const hasBusinessURL = businessURLDetector(item);
      
      // Return true if either condition is met
      return hasBusinessContent || hasBusinessURL;
    },
  },
  // Add other categories here...
};

// For backward compatibility
export const createCategorizedContent = processCategories;

// Default export with all functions
export default {
  processCategories,
  processCategory,
  createCategorizedContent,
  calculateCategoryMetricsWithBoost,
  sortCategoriesByMetrics
};